Spring Data JPA ; crudrepository, ayuda para las transacciones 
 * servicio-usuarios

Feign: escalable, por lso endpoint
 * servicio-item

Ribbon: balanceador de cargas
 * servicio-item

Eureka server: se puede ver los componentes asociados, y cuantas instancias tiene. eureka server junto al eureka client vemos el balanceo de cargas.
 * servicio-eureka-server

Eureka Discovery client:  se retira ribbon, ya que este client contiene la misma funcionalidad
 * servicio-item  	  : agregar en properties => eureka.client.service-url.defaultZone=http://localhost:8761/eureka
 * servicio-productos : agregar en properties => eureka.client.service-url.defaultZone=http://localhost:8761/eureka

 Hystrix: informacion para analizar, cuantas excepciones, cuantos Ok, y Excpecion , metodos alternativos si falla o timeout. 
  * servicio-item     : agregar en properties => hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000âˆ«
												 ribbon.ConnectTimeout: 3000   // para maximo timeout en los metodos. 
												 ribbon.ReadTimeout: 10000
  * servicio-usuarios

Zuul: podemos interactuar mediante un solo puerto, a todos los microservicios, con el uso de ZuulFilter podemos ver el tiempo transcurrido que demora cada evento que hacemos mediante el puerto del zull. tambien configurar error timeoute en properties y metodo alternativo. proteger nuestros recursos 
* servicio-zuul-server


Config Server: se creo properties con puerto 8805 en GIT, para que actualice en caliente. servidor de configuraciones
* config-server


Config Client: 
* servicio-item


Actuator: actualizar mediante un POS: http://localhost:port/actuator/refresh/
*servicio-item

Spring Security: para trabajar con roles, usuarios. privilegios,
* servicio-usuarios

Rest Repositories: se inyecta para utilizar los endpoints a la BD, con los verbos (GET,POS,PUT,DELETE,search)
* servicio-usuarios



bootstrap.properties esta en prioridad a aplication.properties, generalmente en bootstrap va toda configuracion de serverconfig
==============================================================================================================================
-* servicio-config-server   : 8805  Config Server ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 
		main: 	@EnableConfigServer
		x
	properties: 
		spring.application.name=config-server
		server.port=8888
		#spring.cloud.config.server.git.uri=file:/Users/deyvisperez/deyvizperez/udemy/microservicios-springboot-springcloud-netflix-eureka/config
		spring.cloud.config.server.git.uri=https://github.com/dperezg2017/config.git
	dependency: 
  		x Spring Boot DevTools
  		x Config Server

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-item	  		: 8002	Hystrix , Ribbon , Feign, Eureka Discovery client, Config Client, Actuator ************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 
		main: 	@EnableCircuitBreaker
				@EnableEurekaClient
				//@RibbonClient(name = "servicio-productos")
				@EnableFeignClients
				@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
	properties:
		spring.application.name=servicio-items
		server.port=8002
		# servicio-productos.ribbon.listOfServers=localhost:8001,localhost:9001
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka
		hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		ribbon.ConnectTimeout: 3000
		ribbon.ReadTimeout: 10000
	dependency: 
  		x Spring Boot DevTools
  		x Spring Boot Actuator
  		x Hystrix
  		x Config Client
  		x OpenFeign
  		x Eureka Discovery Client
  		x Spring Web

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-productos 		: 9001,8001   Eureka Discovery client  ****************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 

		main: 	@EnableEurekaClient		// Para que se amarre al EurekaServer
				@SpringBootApplication
				@EntityScan({"com.formacionbdi.springboot.app.commons.models.entity"}) // para detectart y reconocer, se separa con comas(,)
		clases: @RestController
				@Autowired
				@Value("${server.port}")
				@GetMapping("/listar")
				@PostMapping("/crear")
				@ResponseStatus(HttpStatus.CREATED)
				@PutMapping("/editar/{id}")
				@DeleteMapping("/eliminar/{id}")
				@ResponseStatus(HttpStatus.NO_CONTENT)
				@Service
				@Override
				@Transactional(readOnly = true)
   	extends:
   		extends: 
   			CrudRepository<Producto, Long>{
   	properties:
		spring.application.name=servicio-productos
		## para que el puerto sea un randon  server.port=8001
		server.port=${PORT:0}
		eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka
	dependency:
  		x Spring Boot DevTools
  		x Spring Data JPA
  		x H2 Database
  		x Eureka Discovery Client
  		x Spring Web

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-eureka-server	: 8761  Eureka server *****************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones:
		main : @EnableEurekaServer
		x
	properties:
		spring.application.name=servicio-eureka-server
		server.port=8761
		eureka.client.register-with-eureka=false
		eureka.client.fetch-registry=false
	dependency:
	  	x Spring Boot DevTools
  		x Eureka Server

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-zuul-server		: 8090 Zuul  ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@EnableEurekaClient
				@EnableZuulProxy
				@SpringBootApplication
		clases: @Component
				@Override
	extends:
		ZuulFilter: PosTiempoTranscurridoFilter2.java
			@Override
			public boolean shouldFilter() {
			// si vamos a ejecutar el run(), para validar
			return true;
			}

			@Override
			public Object run() throws ZuulException {
				RequestContext ctx= RequestContext.getCurrentContext();
				HttpServletRequest request = ctx.getRequest();
				
				LOGGER.info("entrando a post filter");
				
				Long tiempoInicio = (Long) request.getAttribute("tiempoInicio");
				Long tiempoFinal= System.currentTimeMillis();
				Long tiempoTranscurrido = tiempoFinal - tiempoInicio;
				
				
				LOGGER.info(String.format("Tiempo transcurrido en segundos %s segundos.", tiempoTranscurrido.doubleValue()/1000.00));
				LOGGER.info(String.format("Tiempo transcurrido en segundos %s milisegundos", tiempoTranscurrido));
				
				return null;
			}
			@Override
			public String filterType() {
				// POST despues  de la ocmunicacion con el microservicio, pre es palabra clave
				return "post";
			}
		
			@Override
			public int filterOrder() {
				return 1;
			}
		ZuulFilter:	PreTiempoTranscurridoFilter.java
			@Override
			public boolean shouldFilter() {
				// si vamos a ejecutar el run(), para validar
				return true;
			}
		
			@Override
			public Object run() throws ZuulException {
				RequestContext ctx= RequestContext.getCurrentContext();
				HttpServletRequest request = ctx.getRequest();
				
				LOGGER.info(String.format("%s request enrutado a %s", request.getMethod(),request.getRequestURL().toString()));
				
				Long tiempoInicio = System.currentTimeMillis();
				request.setAttribute("tiempoInicio",tiempoInicio);
				return null;
			}
		
			@Override
			public String filterType() {
				// PRE antes se resuelve la ruta, antes de la ocmunicacion con el microservicio, pre es palabra clave
				return "pre";
			}
		
			@Override
			public int filterOrder() {
				return 1;
			}
 	properties: 
		spring.application.name=servicio-zuul-server
		server.port=8090
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		zuul.routes.productos.service-id=servicio-productos
		zuul.routes.productos.path=/api/productos/**
		zuul.routes.items.service-id=servicio-items
		zuul.routes.items.path=/api/items/**
		#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		#ribbon.ConnectTimeout: 3000
		#ribbon.ReadTimeout: 10000
		zuul.routes.usuarios.service-id=servicio-usuarios
		zuul.routes.usuarios.path=/api/usuarios/**
		zuul.routes.security.service-id=servicio-oauth
		zuul.routes.security.path=/api/security/**
	dependency: 
  		x Spring Boot DevTools
  		x Eureka Discovery cLIENT
  		x Spring Web
  		x Zuul
----------------------------------------------------------------------------------------------------------------------------------
-* servicio-commons 		: dependecia  de los microservicios ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
		clases: @Entity
				@Table(name="productos")
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY) // autoincremental
				@Column(name = "create_at")
				@Temporal(TemporalType.DATE)
				@Transient  // no se va mapear para la bd, ya que es temporal
 	properties: 
		spring.application.name=servicio-zuul-server
		server.port=8090
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		zuul.routes.productos.service-id=servicio-productos
		zuul.routes.productos.path=/api/productos/**
		zuul.routes.items.service-id=servicio-items
		zuul.routes.items.path=/api/items/**
		#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		#ribbon.ConnectTimeout: 3000
		#ribbon.ReadTimeout: 10000
	dependency: 
  		x Spring Data JPA
  		x

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-usuarios Hystrix, Spring Data JPA, Rest Repositories **************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones:
 		main:
 			@EntityScan({"com.formacionbdi.springboot.app.commons.models.entity"})
 		clases:	
 			//@ManyToMany(fetch = FetchType.EAGER) // viene por defecto, trae todo en una solo consulta
 			@ManyToMany(fetch = FetchType.LAZYl) // es recomendablem solo trae el dato cuando se hace la consulta. no es necesario aplicarlo en la otra tabla, solo basta en e lprincipal. * a * si en caso se decide seria: 
			//@ManyToMany(fetch = FetchType.LAZY, mappedBy = "roles")
			//private List<Usuario> usuarios;
			@JoinTable(name = "usuarios_to_roles",joinColumns = @JoinColumn(name= "user_id"),inverseJoinColumns = @JoinColumn(	  name="role_id")) // dar nombre por defecto a los llaves
			@JoinTable(name = "usuarios_roles",joinColumns = @JoinColumn(name= "usuario_id"),inverseJoinColumns = @JoinColumn(name="role_id"), uniqueConstraints = {@UniqueConstraint(columnNames = {"usuario_id","role_id"} )}) // dar nombre por defecto a los llaves ,y unique para no se repitan las llaves
			@Configuration // clase de configuracion
		interfaces: 
  			@RepositoryRestResource(path = "usuarios") // donde se va exportar el crudrepository, endpoint localhost:8080/api/usuarios/usuarios 
  			@RestResource(path = "buscar-username")
			 public Usuario findByUsername(@Param("username") String username);
	implements:
		RepositoryRestConfigurer:  // para exponer id en json: GET: http://localhost:8090/api/usuarios/usuarios/
			public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config){
			config.exposeIdsFor(Usuario.class,Role.class);
		}
  	postman:
  		GET: http://localhost:8090/api/usuarios/usuarios 	// lista usuarios
  			 http://localhost:8090/api/usuarios/usuarios/search/findByUsername?username=admin // sin anotacion
  			 http://localhost:8090/api/usuarios/usuarios/search/buscar-username?username=admin // despues de usar anotaciones
  		POS: http://localhost:8090/api/usuarios/usuarios   // crear usuario
			{
			  "username": "pepe",
			  "password": "12345",
			  "enabled": true,
			  "nombre": "Jose",
			  "apellido": "Doe",
			  "email": "jose.doe@hotmail.com",
			  "roles": [
			    {
			      "id":1, "nombre": "ROLE_USER"
			    },
			    {
			      "id":2, "nombre": "ROLE_ADMIN"
			    }
			  ]
			}
		PUT: http://localhost:8090/api/usuarios/usuarios/3   // edita usuario pepe
			{
			  "username": "admin",
			  "password": "12345",
			  "enabled": true,
			  "nombre": "Jose",
			  "apellido": "Doe",
			  "email": "jose.doe@hotmail.com",
			  "roles": [
			    {
			      "id":1, "nombre": "ROLE_USER"
			    },
			    {
			      "id":2, "nombre": "ROLE_ADMIN"
			    }
			  ]
			}
		DELETE: http://localhost:8090/api/usuarios/usuarios/3
 	properties: 
 		spring.application.name=servicio-usuarios
		server.port=${PORT:0}
		eureka.instance.instance-id=${spring.application.name}:${spring.applica
		logging.level.org.hibernate.SQL=debug
	dependency: 
  		x Spring Boot DevTools
  		x Spring data JPA
  		x H2 Database
  		x Eureka Discovery cLIENT
  		x Spring Web
  		x Rest Repositories

 ----------------------------------------------------------------------------------------------------------------------------------
-* servicio-usuarios-commons  Spring Data JPA **************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
		clases: @Entity
				@Table(name = "usuarios")
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY) // autoincremental
				@Column(name = "create_at")
				@ManyToMany(fetch = FetchType.LAZY)
				@JoinTable(name = "usuarios_roles",joinColumns = @JoinColumn(name= "usuario_id"),inverseJoinColumns = @JoinColumn(name="role_id"), 
				uniqueConstraints = {@UniqueConstraint(columnNames = {"usuario_id","role_id"} )})

				@Entity
				@Table(name = "roles")
				//	@ManyToMany(fetch = FetchType.LAZY, mappedBy = "roles")
				//	private List<Usuario> usuarios;
	dependency: 
  		x Spring Data JPA
  		x

 ----------------------------------------------------------------------------------------------------------------------------------
-* servicio-oauth  Spring Boot DevTools, Eureka Discovery Client, Open Feign, Cloud OAuth2, Spring Web ************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones:
		main:
	 		@EnableEurekaClient
	 		@EnableFeignClients
	 	clases:
	 		@Service
	 		@Configuration
	 		@Bean
	 		@EnableAuthorizationServer
	implements:
	 	UserDetailsService: 
			@Service
			public class UsuarioService implements UserDetailsService {
		
			private Logger log = LoggerFactory.getLogger(UsuarioService.class);
		
			@Autowired
			private UsuarioFeignClient client;
		
			@Override
			public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
			Usuario usuario = client.findByUsername(username);
			
			if(usuario==null) {
				throw new UsernameNotFoundException("Error en el login, no existe el usuario'"+username+"' en el sistema");
			}
			// los roles se encuentran GrantedAuthority: de interfaz , SimpleGrantedAuthority pertenece a GrantedAuthority, pero este es la concreta. 
			List<GrantedAuthority> authorities = usuario.getRole()
					.stream()
					.map(role -> new SimpleGrantedAuthority(role.getNombre()))
					.peek(authority -> log.info("Role: "+authority.getAuthority()))
					.collect(Collectors.toList());
					log.info("Usuario autenticado"+username);
			
			return new User(usuario.getUsername(), usuario.getPassword(), usuario.getEnabled(), true, true, true, authorities);
			}
		CommandLineRunner: implementar en la main class, encriptar 4 claves
	extends:
		WebSecurityConfigurerAdapter:  
		AuthorizationServerConfigurerAdapter: 
			@Configuration
			@EnableAuthorizationServer
			public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter{
        
	        @Autowired
	        private BCryptPasswordEncoder passwordEncoder;
	        
	        @Autowired
	        private AuthenticationManager authenticationManager;
        
	        @Override
	        public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
	        	security.checkTokenAccess("permitAll()") // validan token
	        	.checkTokenAccess("isAuthenticated()"); // metodo de spring secuity, permite valida lo autenticado, se envia lciente ID con su secret
	        }
        
	        @Override
	        public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
	        	clients.inMemory().withClient("frontedapp")  // identificado del app fronted
	        	.secret(passwordEncoder.encode("12345"))
	        	.scopes("read","write") // se puede leer y escribir
	        	.authorizedGrantTypes("password","refresh_token")  // usuario que inicia sesion en backend, autencacion login y la concecion, refresh_token, permite tener nuevo token antes que caduque el actual
	        	.accessTokenValiditySeconds(3600) // tiempo para refresh_token
	        	.refreshTokenValiditySeconds(3600);
	        // si en caso se trabaja con mas clientes fronted
	        //		.and()
	        //		.withClient("frontedapp2") 
	        //		.secret(passwordEncoder.encode("12345"))
	        //		.scopes("read","write") 
	        //		.authorizedGrantTypes("password","refresh_token")  
	        //		.accessTokenValiditySeconds(3600) 
	        //		.refreshTokenValiditySeconds(3600);
	        }	
        
	        @Override
	        public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
	        	
	        	endpoints.authenticationManager(authenticationManager)
	        	.tokenStore(tokenStore())
	        	.accessTokenConverter(accessTokenConverter());
	        }
        
	        @Bean
	        public JwtTokenStore tokenStore() {
	        	return new JwtTokenStore(accessTokenConverter()); // crear tokey  almacenar username,roles, pass
	        }
        
	        @Bean
	        private JwtAccessTokenConverter accessTokenConverter() {
	        	JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
	        	tokenConverter.setSigningKey("algun_codigo_secreto_aeiou"); // para que sea unico
	        	return null;
	        }
	interface: 
		@FeignClient(name = "servicio-usuarios")
	properties:
	 	spring.application.name=servicio-oauth
		server.port=9100
		#eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
	pom: 
			<dependency>
			<groupId>com.formacionbdi.springboot.app.commons</groupId>
			<artifactId>springboot-servicio-usuarios-commons</artifactId>
			<version>0.0.1-SNAPSHOT</version>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-data-jpa</artifactId>
				</exclusion>
			</exclusions>
			</dependency>











