Spring Data JPA ; crudrepository, ayuda para las transacciones 
 * servicio-usuarios

Feign: escalable, por lso endpoint
 * servicio-item

Ribbon: balanceador de cargas
 * servicio-item

Eureka server: se puede ver los componentes asociados, y cuantas instancias tiene. eureka server junto al eureka client vemos el balanceo de cargas.
 * servicio-eureka-server

Eureka Discovery client:  se retira ribbon, ya que este client contiene la misma funcionalidad
 * servicio-item  	  : agregar en properties => eureka.client.service-url.defaultZone=http://localhost:8761/eureka
 * servicio-productos : agregar en properties => eureka.client.service-url.defaultZone=http://localhost:8761/eureka

 Hystrix: informacion para analizar, cuantas excepciones, cuantos Ok, y Excpecion , metodos alternativos si falla o timeout. 
  * servicio-item     : agregar en properties => hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000∫
												 ribbon.ConnectTimeout: 3000   // para maximo timeout en los metodos. 
												 ribbon.ReadTimeout: 10000
  * servicio-usuarios

Zuul: podemos interactuar mediante un solo puerto, a todos los microservicios, con el uso de ZuulFilter podemos ver el tiempo transcurrido que demora cada evento que hacemos mediante el puerto del zull. tambien configurar error timeoute en properties y metodo alternativo. proteger nuestros recursos 
* servicio-zuul-server


Config Server: se creo properties con puerto 8805 en GIT, para que actualice en caliente. servidor de configuraciones
* config-server


Config Client: 
* servicio-item


Actuator: actualizar mediante un POS: http://localhost:port/actuator/refresh/
*servicio-item

Spring Security: para trabajar con roles, usuarios. privilegios,
* servicio-usuarios

Rest Repositories: se inyecta para utilizar los endpoints a la BD, con los verbos (GET,POS,PUT,DELETE,search)
* servicio-usuarios

CORS: intercambio de recursos de origen cruzado

Sleuth: implementar traza ([servicio-oauth,a9070806dc196bb9,eb122395f672dbfb,false]) por cada REQUEST con id diferente y unico, si es true exporta la traza a Zipkin.
Zipkin: identificar trazas que genera el Sleuth, span, anotacion que son parametros. http://localhost:9411/, tiene su buscado de trazas al levantar el .exe.jar
	* configurar mysql:
		- github parametro mysql MySQL Storage: https://github.com/openzipkin/zipkin/tree/master/zipkin-server
		-  create table: https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql: 
			CREATE TABLE IF NOT EXISTS zipkin_spans (
			  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
			  `trace_id` BIGINT NOT NULL,
			  `id` BIGINT NOT NULL,
			  `name` VARCHAR(255) NOT NULL,
			  `remote_service_name` VARCHAR(255),
			  `parent_id` BIGINT,
			  `debug` BIT(1),
			  `start_ts` BIGINT COMMENT 'Span.timestamp(): epoch micros used for endTs query and to implement TTL',
			  `duration` BIGINT COMMENT 'Span.duration(): micros used for minDuration and maxDuration query',
			  PRIMARY KEY (`trace_id_high`, `trace_id`, `id`)
			) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
			
			ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTracesByIds';
			ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT 'for getTraces and getSpanNames';
			ALTER TABLE zipkin_spans ADD INDEX(`remote_service_name`) COMMENT 'for getTraces and getRemoteServiceNames';
			ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT 'for getTraces ordering and range';
			
			CREATE TABLE IF NOT EXISTS zipkin_annotations (
			  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
			  `trace_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.trace_id',
			  `span_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.id',
			  `a_key` VARCHAR(255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1',
			  `a_value` BLOB COMMENT 'BinaryAnnotation.value(), which must be smaller than 64KB',
			  `a_type` INT NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation',
			  `a_timestamp` BIGINT COMMENT 'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp',
			  `endpoint_ipv4` INT COMMENT 'Null when Binary/Annotation.endpoint is null',
			  `endpoint_ipv6` BINARY(16) COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address',
			  `endpoint_port` SMALLINT COMMENT 'Null when Binary/Annotation.endpoint is null',
			  `endpoint_service_name` VARCHAR(255) COMMENT 'Null when Binary/Annotation.endpoint is null'
			) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
			
			ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT 'Ignore insert on duplicate';
			ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT 'for joining with zipkin_spans';
			ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTraces/ByIds';
			ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT 'for getTraces and getServiceNames';
			ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT 'for getTraces and autocomplete values';
			ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT 'for getTraces and autocomplete values';
			ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT 'for dependencies job';
			
			CREATE TABLE IF NOT EXISTS zipkin_dependencies (
			  `day` DATE NOT NULL,
			  `parent` VARCHAR(255) NOT NULL,
			  `child` VARCHAR(255) NOT NULL,
			  `call_count` BIGINT,
			  `error_count` BIGINT,
			  PRIMARY KEY (`day`, `parent`, `child`)
			) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;

RabbitMQ: los microservicios son los productores. consumidor seria el servidor zipkin 
	* star rabbit: rabbitmq-serve     detener rabbit: rabbitmqctl stop
	* configuracion window rabbitmq->zipkin en un zipkin.cmd 
		@echo off
		set RABBIT_ADDRESSES=localhost:5672
		set STORAGE_TYPE=mysql
		set MYSQL_USER=zipkin
		set MYSQL_PASS=zipkin
		java -jar ./zipkin-server-2.19.1-exec.jar
	* configuracion MAC rabbitmq->zipkin en un .sh 
		!/bin/sh
		export RABBIT_ADDRESSES=localhost:5672
		export STORAGE_TYPE=mysql
		export MYSQL_USER=zipkin
		export MYSQL_PASS=zipkin
		java -jar ./zipkin-server-2.19.1-exec.jar --server.port=5672

DockerfiLe: 
	* dockerizando el config-server: VOLUME: donde se guarda el historial como log,  ENTRYPOINT: parametros a ejecutar 
		FROM openjdk:8
		VOLUME 	/tmp
		EXPOSE 8888
		ADD ./target/springboot-servicio-config-server-0.0.1-SNAPSHOT.jar
		ENTRYPOINT ["java","-jar","/config-server.jar"]
	* construyendo con docker: siempre el punto(.)
		docker build -t config-server:v1 .
	* para listar las imagenes:
		docker images
	* crear una red para los proyectos:
		docker network create springcloud
	* correr la imagen con el primer puerto que podremos verlo externo y lo podemos ver de nuestro SO y el segundo es el interno o propio del sistema, nombre a ejecutar, nombre de red y nombre de la imagen
		docker run -p 8888:8888 --name config-server --network springcloud config-server:v1
		eliminar is hay otro que lo usa: docker rm -f /config-server
	* 

bootstrap.properties esta en prioridad a aplication.properties, generalmente en bootstrap va toda configuracion de serverconfig
==============================================================================================================================
-* servicio-config-server   : 8805  Config Server ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 
		main: 	@EnableConfigServer
		x
	properties: 
		spring.application.name=config-server
		server.port=8888
		#spring.cloud.config.server.git.uri=file:/Users/deyvisperez/deyvizperez/udemy/microservicios-springboot-springcloud-netflix-eureka/config
		spring.cloud.config.server.git.uri=https://github.com/dperezg2017/config.git
	dependency: 
  		x Spring Boot DevTools
  		x Config Server

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-item	  		: 8002	Hystrix , Ribbon , Feign, Eureka Discovery client, Config Client, Actuator ************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 
		main: 	@EnableCircuitBreaker
				@EnableEurekaClient
				//@RibbonClient(name = "servicio-productos")
				@EnableFeignClients
				@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
	properties:
		spring.application.name=servicio-items
		server.port=8002
		# servicio-productos.ribbon.listOfServers=localhost:8001,localhost:9001
		
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka
		
		#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		#ribbon.ConnectTimeout: 3000
		#ribbon.ReadTimeout: 10000
		
		
		#solo el 10%=0.1 envia la traza al zipkin, para ello se configura
		spring.sleuth.sampler.probability=1.0
		spring.zipkin.base-url=http://localhost:9411/
	bootstrap.properties
		spring.application.name=servicio-items
		spring.profiles.active=dev
		spring.cloud.config.uri=http://localhost:8888
		management.endpoints.web.exposure.include=*
	dependency: 
  		x Spring Boot DevTools
  		x Spring Boot Actuator
  		x Hystrix
  		x Config Client
  		x OpenFeign
  		x Eureka Discovery Client
  		x Spring Web
  		- Sleuth (eliminarlo)
  		x Zipkin Client (contiene Sleuth)
  		x Spring for RabbitMQ
----------------------------------------------------------------------------------------------------------------------------------
-* servicio-productos 		: 9001,8001   Eureka Discovery client  ****************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones: 

		main: 	@EnableEurekaClient		// Para que se amarre al EurekaServer
				@SpringBootApplication
				@EntityScan({"com.formacionbdi.springboot.app.commons.models.entity"}) // para detectart y reconocer, se separa con comas(,)
		clases: @RestController
				@Autowired
				@Value("${server.port}")
				@GetMapping("/listar")
				@PostMapping("/crear")
				@ResponseStatus(HttpStatus.CREATED)
				@PutMapping("/editar/{id}")
				@DeleteMapping("/eliminar/{id}")
				@ResponseStatus(HttpStatus.NO_CONTENT)
				@Service
				@Override
				@Transactional(readOnly = true)
   	extends:
   		extends: 
   			CrudRepository<Producto, Long>{
   	properties:
		spring.application.name=servicio-productos
		## para que el puerto sea un randon  server.port=8001
		server.port=${PORT:0}
		eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
		
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka
		
		#solo el 10%=0.1 envia la traza al zipkin, para ello se configura
		spring.sleuth.sampler.probability=1.0
	dependency:
  		x Spring Boot DevTools
  		x Spring Data JPA
  		x H2 Database
  		x Eureka Discovery Client
  		x Spring Web
  		x MySQL Driver
  		x Config client
  		- Sleuth (eliminarlo)
  		x Zipkin Client (contiene Sleuth)
  		x Spring for RabbitMQ
  	import.sql:
  		INSERT INTO productos (nombre,precio,create_at) VALUES('Panasonic',8020,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Sony',8200,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Apple',8300,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Hewlet',8400,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Bianchi',8100,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Nike',8200,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Adidas',560,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Reebok',3400,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Bmw',1003,NOW());
		INSERT INTO productos (nombre,precio,create_at) VALUES('Lucky',2040,NOW());

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-eureka-server	: 8761  Eureka server *****************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
	anotaciones:
		main : @EnableEurekaServer
		x
	properties:
		spring.application.name=servicio-eureka-server
		server.port=8761
		eureka.client.register-with-eureka=false
		eureka.client.fetch-registry=false
	dependency:
	  	x Spring Boot DevTools
  		x Eureka Server

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-zuul-server		: 8090 Zuul  ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@EnableEurekaClient
				@EnableZuulProxy
				@SpringBootApplication
				@RefreshScope
		clases: @Component
				@Override
				@EnableResourceServer: habilitar recursos para el token
	extends:
		ZuulFilter: PosTiempoTranscurridoFilter2.java
			@Override
			public boolean shouldFilter() {
			// si vamos a ejecutar el run(), para validar
			return true;
			}

			@Override
			public Object run() throws ZuulException {
				RequestContext ctx= RequestContext.getCurrentContext();
				HttpServletRequest request = ctx.getRequest();
				
				LOGGER.info("entrando a post filter");
				
				Long tiempoInicio = (Long) request.getAttribute("tiempoInicio");
				Long tiempoFinal= System.currentTimeMillis();
				Long tiempoTranscurrido = tiempoFinal - tiempoInicio;
				
				
				LOGGER.info(String.format("Tiempo transcurrido en segundos %s segundos.", tiempoTranscurrido.doubleValue()/1000.00));
				LOGGER.info(String.format("Tiempo transcurrido en segundos %s milisegundos", tiempoTranscurrido));
				
				return null;
			}
			@Override
			public String filterType() {
				// POST despues  de la ocmunicacion con el microservicio, pre es palabra clave
				return "post";
			}
		
			@Override
			public int filterOrder() {
				return 1;
			}
		ZuulFilter:	PreTiempoTranscurridoFilter.java
			@Override
			public boolean shouldFilter() {
				// si vamos a ejecutar el run(), para validar
				return true;
			}
		
			@Override
			public Object run() throws ZuulException {
				RequestContext ctx= RequestContext.getCurrentContext();
				HttpServletRequest request = ctx.getRequest();
				
				LOGGER.info(String.format("%s request enrutado a %s", request.getMethod(),request.getRequestURL().toString()));
				
				Long tiempoInicio = System.currentTimeMillis();
				request.setAttribute("tiempoInicio",tiempoInicio);
				return null;
			}
		
			@Override
			public String filterType() {
				// PRE antes se resuelve la ruta, antes de la ocmunicacion con el microservicio, pre es palabra clave
				return "pre";
			}
		
			@Override
			public int filterOrder() {
				return 1;
			}
		ResourceServerConfigurerAdapter: para configurar rutas y token
			@Configuration
			@EnableResourceServer
			@RefreshScope
			public class ResourceServerConfig extends ResourceServerConfigurerAdapter{
			
				@Value("config.security.oauth.jwt.key")
				private String jwtKey;
				
				@Override
				public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
					// PARA CONFIGURAR LAS RUTAS 
					resources.tokenStore(tokenStore());
				}
			
				@Override
				public void configure(HttpSecurity http) throws Exception {
					// PARA CONFIGURAR EL TOKEN
					// http.authorizeRequests().antMatchers("/api/security/oauth/token").permitAll(); solo a la ruta token
					http.authorizeRequests().antMatchers("/api/security/oauth/**").permitAll() // a cualquier tuta token ò etc.
					.antMatchers(HttpMethod.GET,"/api/productos/listar","/api/items/listar","/api/usuarios/usuarios").permitAll() // solo permite GET a esas rutas
					.antMatchers(HttpMethod.GET,"/api/productos/ver/{id}","/api/items/ver/{id}/cantidad/{cantidad}","/api/usuarios/usuarios/{id}").hasAnyRole("ADMIN","USER")
					.antMatchers("api/productos/**","api/items/**","/api/usuarios/**").hasRole("ADMIN")
					.anyRequest().authenticated() // cualquier otro request, necesita ser autenticado. 
					.and().cors().configurationSource(corsConfigurationSource());
			//		Evito hacer los 3 debajo y hago todo en una linea
			//		.antMatchers(HttpMethod.POST,"api/productos/crear","api/items/crear").hasRole("ADMIN")
			//		.antMatchers(HttpMethod.PUT,"/api/productos/editar/{id}","/api/items/editar/{id}", "/api/usuarios/usuarios/{id}").hasRole("ADMIN")
			//		.antMatchers(HttpMethod.DELETE,"/api/productos/eliminar/{id}","/api/items/eliminar/{id}", "/api/usuarios/usuarios/{id}").hasRole("ADMIN");
				}
			
				@Bean
				public CorsConfigurationSource corsConfigurationSource() {
					CorsConfiguration corsConfig= new CorsConfiguration();
					//corsConfig.addAllowedOrigins("*"); // htttp://localhost:4200 del angular 
					corsConfig.setAllowedOrigins(Arrays.asList("*")); // agregar varios dominios, * para que se aplique a cualquiera
					corsConfig.setAllowedMethods(Arrays.asList("POST","GET","PUT","DELETE","OPTIONS"));
					corsConfig.setAllowCredentials(true);
					corsConfig.setAllowedHeaders(Arrays.asList("Authorization","Content-Type"));
					
					UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
					source.registerCorsConfiguration("/**", corsConfig); // ** se aplique a todas las rutas
					return source;
				}
				
				@Bean
				public FilterRegistrationBean<CorsFilter> corsFilter() {
			
					FilterRegistrationBean<CorsFilter> bean = new FilterRegistrationBean<CorsFilter>(new CorsFilter(corsConfigurationSource()));
					bean.setOrder(Ordered.HIGHEST_PRECEDENCE); // DAR PRIORIDAD ALTA
					return bean;
				}
			
				@Bean
				public JwtTokenStore tokenStore() {
					return new JwtTokenStore(accessTokenConverter()); // crear tokey  almacenar username,roles, pass
				}
				
				@Bean
				public JwtAccessTokenConverter accessTokenConverter() {
					JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
					tokenConverter.setSigningKey(jwtKey); // para que sea unico
					return tokenConverter;
				}
				
			}

 	properties: 
		spring.application.name=servicio-zuul-server
		server.port=8090
		
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		
		zuul.routes.productos.service-id=servicio-productos
		zuul.routes.productos.path=/api/productos/**
		
		zuul.routes.items.service-id=servicio-items
		zuul.routes.items.path=/api/items/**
		
		
		zuul.routes.usuarios.service-id=servicio-usuarios
		zuul.routes.usuarios.path=/api/usuarios/**
		
		
		zuul.routes.security.service-id=servicio-oauth
		zuul.routes.security.path=/api/security/**
		# librarte de las cookies, por http
		zuul.routes.security.sensitive-headers=Cookie,Set-Cookie
		
		
		
		hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		ribbon.ConnectTimeout: 3000
		ribbon.ReadTimeout: 10000  
	bootstrap.properties:
		spring.application.name=servicio-zuul-server
		spring.cloud.config.uri=http://localhost:8888
		management.endpoints.web.exposure.include=*
	dependency: 
  		x Spring Boot DevTools
  		x Config Client
  		x Eureka Discovery Client
  		x Spring Web
  		x Zuul
  		x Cloud OAuth2
  		- Sleuth (eliminarlo)
  		x Zipkin Client (contiene Sleuth)
  		x Spring for RabbitMQ
  	postman: 
  		[paso 1] POST: http://localhost:8090/api/security/oauth/token	
  		[paso 2] Authorization:
  		type: bearer token
  		token:  base64.base64.base64  <= se consigue con el Basic Auth y 
----------------------------------------------------------------------------------------------------------------------------------
-* servicio-commons 		: dependecia  de los microservicios ******************************************************************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
		clases: @Entity
				@Table(name="productos")
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY) // autoincremental
				@Column(name = "create_at")
				@Temporal(TemporalType.DATE)
				@Transient  // no se va mapear para la bd, ya que es temporal
 	properties: 
		spring.application.name=servicio-zuul-server
		server.port=8090
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		zuul.routes.productos.service-id=servicio-productos
		zuul.routes.productos.path=/api/productos/**
		zuul.routes.items.service-id=servicio-items
		zuul.routes.items.path=/api/items/**
		#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 20000
		#ribbon.ConnectTimeout: 3000
		#ribbon.ReadTimeout: 10000
	dependency: 
  		x Spring Data JPA
  		x

----------------------------------------------------------------------------------------------------------------------------------
-* servicio-usuarios Hystrix, Spring Data JPA, Rest Repositories **************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones:
 		main:
 			@EntityScan({"com.formacionbdi.springboot.app.commons.models.entity"})
 		clases:	
 			//@ManyToMany(fetch = FetchType.EAGER) // viene por defecto, trae todo en una solo consulta
 			@ManyToMany(fetch = FetchType.LAZYl) // es recomendablem solo trae el dato cuando se hace la consulta. no es necesario aplicarlo en la otra tabla, solo basta en e lprincipal. * a * si en caso se decide seria: 
			//@ManyToMany(fetch = FetchType.LAZY, mappedBy = "roles")
			//private List<Usuario> usuarios;
			@JoinTable(name = "usuarios_to_roles",joinColumns = @JoinColumn(name= "user_id"),inverseJoinColumns = @JoinColumn(	  name="role_id")) // dar nombre por defecto a los llaves
			@JoinTable(name = "usuarios_roles",joinColumns = @JoinColumn(name= "usuario_id"),inverseJoinColumns = @JoinColumn(name="role_id"), uniqueConstraints = {@UniqueConstraint(columnNames = {"usuario_id","role_id"} )}) // dar nombre por defecto a los llaves ,y unique para no se repitan las llaves
			@Configuration // clase de configuracion
		interfaces: 
  			@RepositoryRestResource(path = "usuarios") // donde se va exportar el crudrepository, endpoint localhost:8080/api/usuarios/usuarios 
  			@RestResource(path = "buscar-username")
			 public Usuario findByUsername(@Param("username") String username);
	implements:
		RepositoryRestConfigurer:  // para exponer id en json: GET: http://localhost:8090/api/usuarios/usuarios/
			public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config){
			config.exposeIdsFor(Usuario.class,Role.class);
		}
  	postman:
  		GET: http://localhost:8090/api/usuarios/usuarios 	// lista usuarios
  			 http://localhost:8090/api/usuarios/usuarios/search/findByUsername?username=admin // sin anotacion
  			 http://localhost:8090/api/usuarios/usuarios/search/buscar-username?username=admin // despues de usar anotaciones
  		POS: http://localhost:8090/api/usuarios/usuarios   // crear usuario
			{
			  "username": "pepe",
			  "password": "12345",
			  "enabled": true,
			  "nombre": "Jose",
			  "apellido": "Doe",
			  "email": "jose.doe@hotmail.com",
			  "roles": [
			    {
			      "id":1, "nombre": "ROLE_USER"
			    },
			    {
			      "id":2, "nombre": "ROLE_ADMIN"
			    }
			  ]
			}
		PUT: http://localhost:8090/api/usuarios/usuarios/3   // edita usuario pepe
			{
			  "username": "admin",
			  "password": "12345",
			  "enabled": true,
			  "nombre": "Jose",
			  "apellido": "Doe",
			  "email": "jose.doe@hotmail.com",
			  "roles": [
			    {
			      "id":1, "nombre": "ROLE_USER"
			    },
			    {
			      "id":2, "nombre": "ROLE_ADMIN"
			    }
			  ]
			}
		DELETE: http://localhost:8090/api/usuarios/usuarios/3
 	properties: 
		spring.application.name=servicio-usuarios
		server.port=${PORT:0}
		eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
		eureka.client.service-url.defaultZone=http://localhost:8761/eureka
		logging.level.org.hibernate.SQL=debug
		
		#solo el 10%=0.1 envia la traza al zipkin, para ello se configura
		spring.sleuth.sampler.probability=1.0
	dependency: 
  		x Spring Boot DevTools
  		x Spring data JPA
  		x H2 Database
  		x Eureka Discovery cLIENT
  		x Spring Web
  		x Rest Repositories
  		x Postgress SQL Driver
  		x Config Client
		- Sleuth (eliminarlo)
  		x Zipkin Client (contiene Sleuth)
  		x Spring for RabbitMQ
  	import.sql:
  		INSERT INTO usuarios(username,password,enabled,nombre,apellido,email) VALUES ('deyviz','$2a$10$4KmymFJiXCcDdNFpfqBoXOfxWAcfBjXhvIn095bPnXsgnRA7ghDMe',1,'Deyviz','Perez','dperezg2017@gmail.com');
		INSERT INTO usuarios(username,password,enabled,nombre,apellido,email) VALUES ('eliodoro','$2a$10$dD5g3VnJTpSSZPi2IcTqDuaUrdsAXayyVPipAOrsTykCPiJfjoqHW',1,'Eliodoro','Chavez','dperezc2017@hotmail.com');
		
		INSERT INTO roles(nombre) VALUES ('ROLE_USER');
		INSERT INTO roles(nombre) VALUES ('ROLE_ADMIN');
		
		INSERT INTO usuarios_roles(usuario_id,role_id) VALUES (1,1);
		INSERT INTO usuarios_roles(usuario_id,role_id) VALUES (2,2);
		INSERT INTO usuarios_roles(usuario_id,role_id) VALUES (2,1);

 ----------------------------------------------------------------------------------------------------------------------------------
-* servicio-usuarios-commons  Spring Data JPA **************************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones
 		main:	@SpringBootApplication
				@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
		clases: @Entity
				@Table(name = "usuarios")
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY) // autoincremental
				@Column(name = "create_at")
				@ManyToMany(fetch = FetchType.LAZY)
				@JoinTable(name = "usuarios_roles",joinColumns = @JoinColumn(name= "usuario_id"),inverseJoinColumns = @JoinColumn(name="role_id"), 
				uniqueConstraints = {@UniqueConstraint(columnNames = {"usuario_id","role_id"} )})

				@Entity
				@Table(name = "roles")
				//	@ManyToMany(fetch = FetchType.LAZY, mappedBy = "roles")
				//	private List<Usuario> usuarios;
	dependency: 
  		x Spring Data JPA
  		x Config Client


 ----------------------------------------------------------------------------------------------------------------------------------
-* servicio-oauth  Spring Boot DevTools, Eureka Discovery Client, Open Feign, Cloud OAuth2, Spring Web ************
----------------------------------------------------------------------------------------------------------------------------------
 	anotaciones:
		main:
	 		@EnableEurekaClient
	 		@EnableFeignClients
	 	clases:
	 		@Service
	 		@Configuration
	 		@Bean
	 		@EnableAuthorizationServer
	implements:
	 	UserDetailsService: 
			@Service
			public class UsuarioService implements UserDetailsService {
		
			private Logger log = LoggerFactory.getLogger(UsuarioService.class);
		
			@Autowired
			private UsuarioFeignClient client;
		
			@Override
			public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
			Usuario usuario = client.findByUsername(username);
			
			if(usuario==null) {
				throw new UsernameNotFoundException("Error en el login, no existe el usuario'"+username+"' en el sistema");
			}
			// los roles se encuentran GrantedAuthority: de interfaz , SimpleGrantedAuthority pertenece a GrantedAuthority, pero este es la concreta. 
			List<GrantedAuthority> authorities = usuario.getRole()
					.stream()
					.map(role -> new SimpleGrantedAuthority(role.getNombre()))
					.peek(authority -> log.info("Role: "+authority.getAuthority()))
					.collect(Collectors.toList());
					log.info("Usuario autenticado"+username);
			
			return new User(usuario.getUsername(), usuario.getPassword(), usuario.getEnabled(), true, true, true, authorities);
			}
		CommandLineRunner: implementar en la main class, encriptar 4 claves
		TokenEnhancer: agregar informacion adicional al token
			@Component
			public class InfoAdicionalToken implements TokenEnhancer {
				
				@Autowired
				private IUsuarioService usuarioService;
			
				@Override
				public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {
					Map<String, Object> info = new HashMap<String, Object>();
					Usuario usuario = usuarioService.findByUsername(authentication.getName());
					info.put("nombre",usuario.getNombre());
					info.put("apellido",usuario.getApellido());
					info.put("correo",usuario.getEmail());
					((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);
					return accessToken;
				}
			}
	extends:
		WebSecurityConfigurerAdapter:  
		AuthorizationServerConfigurerAdapter: 
			@Configuration
			@EnableAuthorizationServer
			public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter{
        
	        @Autowired
	        private BCryptPasswordEncoder passwordEncoder;
	        
	        @Autowired
	        private AuthenticationManager authenticationManager;
        
	        @Override
	        public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
	        	security.checkTokenAccess("permitAll()") // validan token
	        	.checkTokenAccess("isAuthenticated()"); // metodo de spring secuity, permite valida lo autenticado, se envia lciente ID con su secret
	        }
        
	        @Override
	        public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
	        	clients.inMemory().withClient("frontedapp")  // identificado del app fronted
	        	.secret(passwordEncoder.encode("12345"))
	        	.scopes("read","write") // se puede leer y escribir
	        	.authorizedGrantTypes("password","refresh_token")  // usuario que inicia sesion en backend, autencacion login y la concecion, refresh_token, permite tener nuevo token antes que caduque el actual
	        	.accessTokenValiditySeconds(3600) // tiempo para refresh_token
	        	.refreshTokenValiditySeconds(3600);
	        // si en caso se trabaja con mas clientes fronted
	        //		.and()
	        //		.withClient("frontedapp2") 
	        //		.secret(passwordEncoder.encode("12345"))
	        //		.scopes("read","write") 
	        //		.authorizedGrantTypes("password","refresh_token")  
	        //		.accessTokenValiditySeconds(3600) 
	        //		.refreshTokenValiditySeconds(3600);
	        }	
        
	        @Override
	        public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
	        	
	        	endpoints.authenticationManager(authenticationManager)
	        	.tokenStore(tokenStore())
	        	.accessTokenConverter(accessTokenConverter());
	        }
        
	        @Bean
	        public JwtTokenStore tokenStore() {
	        	return new JwtTokenStore(accessTokenConverter()); // crear tokey  almacenar username,roles, pass
	        }
        
	        @Bean
	        private JwtAccessTokenConverter accessTokenConverter() {
	        	JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
	        	tokenConverter.setSigningKey("algun_codigo_secreto_aeiou"); // para que sea unico
	        	return null;
	        }
	interface: 
		@FeignClient(name = "servicio-usuarios")
	properties:
		spring.application.name=servicio-oauth
		server.port=9100
		#eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
		eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
		
		#solo el 10%=0.1 envia la traza al zipkin, para ello se configura
		spring.sleuth.sampler.probability=1.0
	bootstrap.properties:
		spring.application.name=servicio-oauth
		spring.cloud.config.uri=http://localhost:8888
		management.endpoints.web.exposure.include=*
	pom: 
			<dependency>
			<groupId>com.formacionbdi.springboot.app.commons</groupId>
			<artifactId>springboot-servicio-usuarios-commons</artifactId>
			<version>0.0.1-SNAPSHOT</version>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-data-jpa</artifactId>
				</exclusion>
			</exclusions>
			</dependency>
	postman:
		[paso 1] POS: http://localhost:8090/api/security/oauth/token
		[paso 2] Authorization: ir al modulo 
				  	type: Basic Auth
				  	usernmae: frontedapp  // clave escrita en el backend
				  	password: 12345 // clave escrita en el backend 
				  	previewrequest: clic en el boton 
				    header: se genera un codigo
				    key: Authorization
				    value: Basic ZnJvbnRlZGFwcDoxMjM0NQ==  // esto quiere decir 'Basic' + Base64.encode('frontedapp'+'12345')
		[paso 3] Body: ir al modulo 
					x-wwww-form-urlencoded: selecciona el radio button. y agregar los keys y dar SEND
						key: username 	value: admin
						key: password 	value: 12345
						key:grant_type  value:password
		[usar resfresh]	en Body:
				grant_type				refresh_token	
				refresh_token			base64.base64.base64
	dependency: 
  		x Spring Boot DevTools
  		x Eureka Discovery Client
  		x Open Feign
  		x Cloud OAuth2
  		x Spring Web
  		x Config Client
  		- Sleuth (eliminarlo)
  		x Zipkin Client (contiene Sleuth)
  		x Spring for RabbitMQ










